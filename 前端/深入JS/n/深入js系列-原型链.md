### 起因
从初学到现在，我发现关于原型链的解释都停留在原型链本身，从一个事物的多方面去了解一个事物，是非常有益的，所以今天突然就有灵感(其实是压制不住自己的思维)，借助链表和javascript类背后的原型委托思想来解释原型。

#### 原型链的本质----> 特殊链表

##### 普通链表


![](https://user-gold-cdn.xitu.io/2019/4/15/16a1f46b93ab3e75?w=975&h=205&f=png&s=7086)

##### 原型链表(以""为例)
就像我们一般设置的链表中的next指针，javascript为了我们提供了**内置的next指针__proto__**,对于原型链表，由于不想普通单向链表项一样都是同一个类派生的对象，在这里我称原型链为特殊链表

![](https://user-gold-cdn.xitu.io/2019/4/15/16a1f4e218805b05?w=867&h=204&f=png&s=7476)

##### 类模拟背后的思想-委托
这里提一下，JavaScript本身并没有提供“继承”，继承的本意是复制，而javascript本身实现所谓的继承，是将属性进行代理得到的，而代理的意思，就是我在你身上没有找到属性，那么就去与你关联的上级**__proto__链接的下一个节点**去找这个属性

##### prototype只是一个“特殊的节点类型”
**原型链的本质是为了实现属性的[[GET]]操作，prototype我认为是为了在使用构造函数创建对象时，自动设置链表中的next属性，即将对象的__proto__链接到构造函数的prototype属性的语法糖**

###### 一个不使用prototype实现属性委托的例子
```js
let a = {
  a: 1
}
let b = {
  b: 2
}
let c = {
  cj: "cc"
}
Object.setPrototypeOf(a,b) // 等同于a.__proto__ = b 
Object.setPrototypeOf(b, c) // 等同于 b.__proto__ = c
console.log(a.cj)
console.log(a.b)
console.log(a.a)
```
这里无需借助构造函数的prototype属性，一样可以实现属性的委托。
##### 使用prototype作为特殊节点的好处
1. 使用构造函数时，能够自动将生成对象的__proto__指向构造器的prototype
2. 不需要额外再创建节点，可以在利用现有的prototype属性指向的对象

### 一句话描述原型链
一条能够让在内部实现属性代理的委托链表

### 总结
原型链是一条是对象自身作为头节点，内置的__proto__作为next指针，构造器的prototype作为后续节点的特殊单链表

### “鼓励”
现在不像以前大佬们开荒，全靠自学，很多大佬们都出了自己的博客，写的很好，我希望能够沉进去技术里面，所以不时会埋头写点文章，希望能够得到大家的[小星星](https://github.com/869288142/blog)，以资鼓励，当然新人写的东西，无论是排版还是严谨方面都有待提高，更多希望大家提出自己的意见，帮助我这个萌新学习。