####作用域

#####为什么需要作用域
变量引入程序会引起几个很有意思的问题，也正是我们将要讨论的：这些变量住在哪里？换句话说，它们储存在哪里？最重要的是，程序需要时如何找到它们？

**这些问题说明需要一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。这套规则被称为作用域。**

#####编译原理

javaScript通常被归类为动态、解释执行语言，但事实上它是一门编译语言，这一开始也打破了我对动态解释、静态编译的理解，js引擎进行编译的步骤和传统编译语言非常相似

######传统编译步骤
分词/词法分析 将字符串分解成对语言有意思的代码块
eg: var a = 2; => var a = 2 ; 

解析/语法分析 生成AST
这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法
结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。
var a = 2; 的抽象语法树中可能会有一个叫作VariableDeclaration 的顶级节点，接下
来是一个叫作Identifier（它的值是a）的子节点，以及一个叫作AssignmentExpression
的子节点。AssignmentExpression 节点有一个叫作NumericLiteral（它的值是2）的子
节点

代码生成 
将AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。抛开具体细节，简单来说就是有某种方法可以将var a = 2; 的AST 转化为一组机器指令，用来创建一个叫作a 的变量（包括分配内存等），并将一个值储存在a 中。

######javaScript引擎额外工作
在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化
等，这部分可以查看V8引擎对js的编译步骤

#####理解作用域

######javaScript工作下的“成员”
**引擎**
从头到尾负责整个JavaScript 程序的编译及执行过程。
**编译器**
引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。
**作用域**
引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

######三者的协调
当你看见var a = 2; 这段程序时，很可能认为这是一句声明。但我们的新朋友引擎却不这
么看。事实上，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一
个则由引擎在运行时处理。

下面我们将var a = 2; 分解，看看引擎和它的朋友们是如何协同工作的。
编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编
译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。

可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：“为一个变量分配内存，将其命名为a，然后将值2 保存进这个变量。”然而，这并不完全正确。
事实上编译器会进行如下处理。

1.遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的
集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作
用域的集合中声明一个新的变量，并命名为a。

2.接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2 这个赋值
操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a 的
变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量（查看1.3
节）。
如果引擎最终找到了a 变量，就会将2 赋值给它。否则引擎就会举手示意并抛出一个异
常！

**总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如
果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对
它赋值。**

######编译器查找规则

LHS 取容器 变量出现在赋值操作左侧
RHS 取值 变量出现在赋值操作右侧

######一个详细例子

```js
function foo(a) {
  console.log( a ); // 2
}
foo( 2 );
```

引擎和作用域的交互(以LHS、RHS角度)

先查找foo的值(RHS),执行时需要找到a的形参(LHS),执行console.log先需要找到console(RHS),然后console.log(a)，需要再看一下a的值(RHS)

######作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，
或抵达最外层的作用域（也就是全局作用域）为止

```js
function foo(a) {
  console.log( a + b );
}
var b = 2;
foo( 2 ); // 4
```
这里b无法在函数内部RHS查找失败，但可以在全局作用域找到

######为什么分辨LHS和RHS很重要

在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。

```js
function foo(a) {
  console.log( a + b );
  b = a;
}
foo( 2 );
```

b由于RHS查找失败，会抛出ReferenceError: b is not defined

LHS失败时， 在非严格模式下，会在创建全局变量，严格模式下会报错ReferenceError: b is not defined


#####js作用域模型  词法作用域

简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域
不变（大部分情况下是这样的


######查找

作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，
作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。


######欺骗词法

欺骗词法作用域会导致性能下降，我们在这里这是展示用法

**eval**
```js
// 非严格模式
function foo(str, a) {
  eval( str ); // 欺骗！
  console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3

function foo(str) {
  "use strict";
  eval( str );
  console.log( a ); // ReferenceError: a is not defined
}
foo( "var a = 2" );
```

本来在不知情下，应该引用全局作用域的b(2),但是eval动态修改了foo的词法作用域，创建了一个变量b(3),将全局作用域的b屏蔽了

**with**

with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身

```js
var obj = {
a: 1,
b: 2,
c: 3
};
// 单调乏味的重复"obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;
// 简单的快捷方式
with (obj) {
a = 3;
b = 4;
c = 5;
}
```

问题
```js
function foo(obj) {
  with (obj) {
    a = 2;
  }
}
var o1 = {
  a: 3
};
var o2 = {
  b: 3
};
foo( o1 );
console.log( o1.a ); // 2
foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2——不好，a 被泄漏到全局作用域上了！
```

foo(o2)执行时，由于o2的a属性LHS失败，会在全局作用域下创建a

#####js中的作用域常见作用域