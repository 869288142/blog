####作用域
#####引擎
从头到尾负责整个JavaScript 程序的编译及执行过程。

#####编译器
引擎的好朋友之一，负责语法分析及代码生成等脏活累活

#####作用域
引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查
询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

#####一个有趣的例子
当你看见var a = 2; 这段程序时，很可能认为这是一句声明。但我们的新朋友引擎却不这么看。事实上，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。

#####分析


编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。

可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：“为一个变量分配内存，将其命名为a，然后将值2 保存进这个变量。”然而，这并不完全正确。
事实上编译器会进行如下处理。
1. 遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。

2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a 的
变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。如果引擎最终找到了a 变量，就会将2 赋值给它。否则引擎就会举手示意并抛出一个异
常！
#####总结
变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

#####编译器查找规则
LHS 取容器 
RHS 取值







作用域链
从当前作用域起点到全局作用域

LHS 在非严格模式下会自动创建变量
RHS 抛出ReferenceError异常

词法作用域(关注何处声明) 作用域规则  还有一种是动态作用域(Bash)(关注何处调用)

词法阶段

词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋
予单词语义


修改、欺骗词法，导致作用域链异常  会导致性能下降  

eval

function foo(str, a) {
eval( str ); // 欺骗！
console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
eval(..) 调用中的"var b = 3;" 这段代码会被当作本来就在那里一样来处理。由于那段代
码声明了一个新的变量b，因此它对已经存在的foo(..) 的词法作用域进行了修改。事实
上，和前面提到的原理一样，这段代码实际上在foo(..) 内部创建了一个变量b，并遮蔽
了外部（全局）作用域中的同名变量。
当console.log(..) 被执行时，会在foo(..) 的内部同时找到a 和b，但是永远也无法找到
外部的b。因此会输出“1, 3”而不是正常情况下会输出的“1, 2”

with 可以不需要重复引用对象本身 创建新的词法作用域
var obj = {
a: 1,
b: 2,
c: 3
};
// 单调乏味的重复"obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;
// 简单的快捷方式
with (obj) {
a = 3;
b = 4;
c = 5;
}

函数作用域 IIFE

块作用域 {}显式定义块
try {
undefined(); // 执行一个非法操作来强制制造一个异常
}
catch (err) {
console.log( err ); // 能够正常执行！
}
console.log( err ); // ReferenceError: err not found


