# 变量声明

## 变量声明方式

### var

```js
// 语法  var varName = value
var a = 1  // 这样子你就得到了一个变量
```

### var缺陷场景分析

```js
var specialUser = "cj"; // 在A文件定义
 
var specialUser = "fk"; // A文件很大，你没去寻找是否定义此变量，直接定义

getImportantInformation(specialUser); // 在B文件定义

```

我们在定义一个变量，通常是**跳过检查是否已经定义了此变量**，尤其在编写局部代码时，这就更加**容易导致了命名引起的重复定义，导致一些核心变量被覆盖，造成系统重大破坏**，在上面的例子，就会因为spcialUser变量导致系统使用到该变量的地方全部行为异常，人**要学会偷懒，是否定义此变量，编译器能够知道**，为什么要我们程序员去定义变量前，还要在项目文件下查找此变量是否定义呢，**代码编译时，如果有此变量的定义，直接告诉我们冲突，我们根据需要更换就好**。


### let 如何解决变量覆盖

其实上述覆盖掉了核心变量，我是在业务上遇到过的，估计不少程序猿遇到这种事情

```js
let name = "cj"; // 无论在何处定义
let name = "cj"; // 如果在同一作用域定义此变量，那么会想下图报错
```

![nDrJln.png](https://s2.ax1x.com/2019/09/12/nDrJln.png)

如果变量定义作用域有了同名的变量，解释器就会告诉你，你和别人重名了，需要换名字，**有了let从此就不用再担心原先的变量被覆盖了，放心定义变量即可，很舒服。**

### 缺失块级作用域的var

作用域有一个通俗的理解就是实现了一个减少冲突的机制。

作用域解决了2个问题：
1. 命名冲突
2. 限制范围

这里特别讲一下限制范围的好处

```js
var a = 1 
// 中间隔了很多行
if(condition) {
  var a  = 3  
}
// 中间隔了很多行
console.log(a) //3
```

在这里，开发者并不会去查看他要声明的a是否已经存在，导致了外部的a变量被覆盖了，而且这个行为是静默成功的，开发者无从得知，这非常糟糕，**另外一方面，当你重构这段代码时，你需要关注的作用域不只是if块，而是第一个块级作用域，var时一般是第一个函数或者全局作用域，增加了维护的成本**

### let遗漏的场景


```js
let PI = 3.14

PI = 3.14132
```

**有时候我们需要定义一个变量，在很多地方使用，但是由于这个变量很重要，所以后续有对它的修改，都是会对程序造成破坏**，我们不希望，但是，**当我们对一个变量赋值时，怎么知道其是不能修改的呢，嗯，只能阅读源码，确定其重要性，这样费事费力，新的声明符const帮助我们解决了这个问题**

```js
const PI = 3.14
PI = 3.14132
```

![nDcZ4S.png](https://s2.ax1x.com/2019/09/13/nDcZ4S.png)

在我们想修改一些值时，如果**作者有使用const标记为不可修改变量，那么我们修改时，编译器就会告诉我们，这个变量不能改变，真是棒极了。**

## 总结

**在新的语法大环境下，大家尽可能使用let 去定义变量，在这基础上，如果是不需要改变的变量，可以使用const去定义**，一方面可以避免别人修改，一方面也可以提升编译器效率。



