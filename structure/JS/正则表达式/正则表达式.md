# 正则表达式

正则表达式本身是一种**匹配模式**，用计算机语言来描述我们需要匹配到的结构

# 正则表达式语法

正则表达式从匹配形式来说，**要么匹配字符，要么匹配位置，以下从分别这两点展开学习**

## 匹配字符

### 横向模糊匹配

`正则匹配到的字符串是不固定的 可以使用量词来指定片段出现的次数，次数会影响到字符串的长度，因为称之为横向模糊匹配`

**示例** 

```js
var regex = /ab{2,5}c/g ;   //g 含有一个a，2-5个b，一个c的字符串

var string = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";
console.log( string.match(regex) );

// 匹配结果，只有满足前后位ac，中间只有2-5个b的字符串都匹配到了
// => ["abbc", "abbbc", "abbbbc", "abbbbbc"]
```
**量词** 

`指定需要匹配的字符次数，一些常见的次数表示可以用等价的符号代替，如下图：` 

![](https://user-gold-cdn.xitu.io/2019/5/19/16ace06baee1c6b1?w=1298&h=379&f=png&s=134400)

### 纵向模糊匹配 

`表示同一个位置可以匹配多种可能的字符`

**示例**

```js
var regex = /a[123]b/g;  // 匹配以a开头，以b结尾，中间含有123任意其中一个的字符

var string = "a0b a1b a2b a3b a4b";
console.log( string.match(regex) );

// 匹配结果
// => ["a1b", "a2b", "a3b"]
```

**字符组**

`常见的纵向模糊匹配集合别名`

**字符组**

![](https://user-gold-cdn.xitu.io/2019/5/19/16ace03ed150a001?w=1287&h=545&f=png&s=221337)


### 字符匹配案例分析

1.匹配日期

    匹配 2017-06-10

**分析**

    年  四位数字即可  [0-9]{4}
    月，分为0开头和1开头  0[1-9] | 1[0-2]
    日，分为0、1、2、3开头  0[1-9] | [12][1-9] | 3[01]

**正则**

```js
var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;
console.log( regex.test("2017-06-10") );
// => true
```

2.匹配id

**分析**

  id=".*"  但是由于*是贪婪匹配，就会匹配到最后一个双引号为止
  
  id=".*?" 可以使用惰性匹配来解决，但是效率低下

  id="[^"]*" 最佳

**正则**

```js
var regex = /id="[^"]*"/
var string = '<div id="container" class="main"></div>';
console.log(string.match(regex)[0]);
// => id="container"
```

## 位置匹配

位置在正则中表示相邻字符之间的位置，有以下描点

### ^ 

`表示字符串开头,多行字符表示行开头`

### $ 结尾

`表示字符串开头,多行字符表示行结尾`

下面我们可以把字符串的开头和结尾用'#'代替

**单行**

```js
var result = "hello".replace(/^|$/g, '#');
console.log(result);

// => "#hello#"
```

**多行**

```js
var result = "I\nlove\njavascript".replace(/^|$/gm, '#');
console.log(result);

/*
#I#
#love#
#javascript#
*/
```

###  \b 单词边界

\b 是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置。

```js
var result = "[JS] Lesson_01.mp4".replace(/\b/g, '#');
console.log(result);
// => "[#JS#] #Lesson_01#.#mp4#"
```
### \B  非单词边界

```js      
var result = "[JS] Lesson_01.mp4".replace(/\B/g, '#');
console.log(result);
// => "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"
```

### (?=p)  先行断言

`比如 (?=l)，表示 "l" 字符前面的位置，不包括p模式匹配的字符`

```js
var result = "hello".replace(/(?=l)/g, '#');
console.log(result);
// => "he#l#lo"
```     

### (?!p) 是 (?=p) 取反 先行否定断言

`除匹配p模式前面以外的位置`

```js
var result = "hello".replace(/(?!l)/g, '#');
console.log(result);
// => "#h#ell#o#"
```

### (?<=p) 后行断言

`位置前面要满足匹配p模式，不包括p模式匹配的字符`

```js
var result = "hello".replace(/(?<=l)/g, '#');
console.log(result);
// => "hel#l#o"
``` 

###  (?<!p) 后行否定断言

`位置前面要满足匹配p模式，除此位置的其余位置`

```js
var result = "hello".replace(/(?<=l)/g, '#');
console.log(result);
// => "#h#e#llo#"
``` 

### 位置匹配案例分析

1.数字千位分隔符表示法

比如把 "12345678"，变成 "12,345,678"。

**分析**

    这个匹配一看就是匹配3位数字的前面的位置，可以使用先行断言来匹配 ?=\d{3}+， 就可以做到

**正则**

```js
var result = "12345678".replace(/(?=(\d{3})+$)/g, ',')
console.log(result);
// => "12,345,678"

// 这里尝试3的倍数位数字会发现开头也加上了,
var result = "112345678".replace(/(?=(\d{3})+$)/g, ',')
console.log(result);
// => ",112,345,678"

// 限制此位置不能是开头即可
var regex = /(?!^)(?=(\d{3})+$)/g;
result = "123456789".replace(regex, ',');
console.log(result);
// => "123,456,789"
```

1.实现字符串trim方法

**分析**

trim是用来去除字符串首尾空白符，嗯，一读这句话，首尾，那不就是首尾
^ $嘛，至于空白符\s就完事了

**正则**

```js
function trim(str) {
  return str.replace(/^\s+|\s+$/g, '')
}
console.log(trim(' foobar '))
```

trim方法是实现首尾去除空白符的，那么新推出的trimStart,trimEnd如何实现呢,嘻嘻，大家可以想想


## 元字符转义问题

转义这个问题是指一些符号在正则中拥有特殊的含义，比如^表示字符串起始位置，那么如何表示^这个字符串呢，那么就需要特殊的方法，成为转义，**转义只需要在字符前加上\\**

### 正则表达式元字符

    ^、$、.、*、+、?、|、\、/、(、)、[、]、{、}、=、!、:、- ,  

## 匹配行为-贪婪匹配和惰性匹配

这里的**匹配行为由将我们正则转为计算机语言的状态机决定**，常见的有DFA和NFA, 目前比较常见的是NFA，JavaScript也是采用NFA实现的正则引擎，NFA一个特点就是会产生回溯行为，生动地来将，**它采用类似深度优先搜索思想，遍历可能匹配的字符串，一旦下一次匹配失效，即可回退到前一个状态，听起来很像拿着线球走出迷宫的故事**，回溯行为从直观想就能得知会影响效率，在JavaScript正则中，**常见的回溯形式为贪婪量词、惰性量词、分支结构**，下面会依次介绍

### 贪婪匹配 

`最大范围匹配`

```js    
var regex = /\d{2,5}/g;
var string = "123 1234 12345 123456";
console.log( string.match(regex) );
// => ["123", "1234", "12345", "12345"]
```

示例中会将数字尽可能匹配到，所以看到匹配的数字都是依照空白符分割开来的

### 惰性匹配 ?

`最小匹配范围`

```js     
var regex = /\d{2,5}?/g;
var string = "123 1234 12345 123456";
console.log( string.match(regex) );
// => ["12", "12", "34", "12", "34", "12", "34", "56"]
```
示例中，加了？的量词之后，正则会在匹配2个数字之后停止

## 多选分支 
`子模式任选其一 属于惰性匹配具体形式如下：(p1|p2|p3)，其中 p1、p2 和 p3 是子模式，用 |（管道符）分隔，表示其中任何之一。`
```js  
var regex = /good|nice/g;
var string = "good idea, nice try.";
console.log( string.match(regex) );
// => ["good", "nice"]
```  

## 括号

在很多语言语法中，括号最常见的是代表优先级，我们看看括号在正则表达式中有什么特殊的用途呢？

### 产生整体

```js
/ab+/ => a接上至少一个b
如何把量词作用与一个整体 
/(ab)+/
```
### 分支结构

`表达分支的可能性`

```js
表示p1或p2表达式任选其一
var regex = /^I love (JavaScript|Regular Expression)$/;
console.log( regex.test("I love JavaScript") );
console.log( regex.test("I love Regular Expression") );
```

### 分组引用

`用于捕获括号匹配的结果`

**提取数据**

**括号里的匹配字符串可以被直接引用，用以特定的场景**

提取年月日

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/g;
var string = "2017-06-12";
console.log( string.match(regex) );
console.log( RegExp.$1 ); // 2017
console.log( RegExp.$2 ); // 06
console.log( RegExp.$3 ); // 12
```
**替换**

日期更换格式

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, "$2/$3/$1");
console.log(result);
// => "06/12/2017"
```

### 反向引用

`可以引用之前出现的分组结果`

有时候需要引用前面匹配的结果，比如说下面要求日期分隔符一致

```js
// 1表示出现的一个分组中的匹配结果
var regex = /\d{4}(-|\/|\.)\d{2}\1\d{2}/;
var string1 = "2017-06-12";
var string2 = "2017/06/12";
var string3 = "2017.06.12";
var string4 = "2016-06/12";
console.log( regex.test(string1) ); // true
console.log( regex.test(string2) ); // true
console.log( regex.test(string3) ); // true
console.log( regex.test(string4) ); // false
```

### 非捕获括号

`不捕获匹配的结果`

```js
var regex = /(?:ab)+/g;
var string = "ababa abbb ababab";
console.log( string.match(regex) );
// => ["abab", "ab", "ababab"]
```

### 括号案例
```js
// 驼峰化
function camelize (str) {
return str.replace(/[-_\s]+(.)?/g, function (match, c) {
return c ? c.toUpperCase() : '';
});
}
console.log( camelize('-moz-transform') );


// 中划线化
function dasherize (str) {
return str.replace(/([A-Z])/g, '-$1').replace(/[-_\s]+/g, '-').toLowerCase();
}
console.log( dasherize('MozTransform') );
```

## 操作符优先级

![](https://user-gold-cdn.xitu.io/2019/5/19/16ace49055253f4e?w=1334&h=592&f=png&s=293609)

![](https://user-gold-cdn.xitu.io/2019/5/19/16ace49575592d8a?w=1350&h=406&f=png&s=94394)


## 正则表达式可视化

emmmm,虽然有优先级，但是有时候还是会看不懂，使用可视化工具帮助我们理解是一个很不错的idea，这里有一个[正则可视化网址](https://regexper.com/),在阅读不懂的正则表达式可以助你一臂之力。

## 正则表达式的构建

如何针对问题，构建一个合适的正则表达式

### 法则

**1.是否有必要使用正则**

人在学习一个新东西之后，很容易陷入到无所不用，正则亦是如此，其实很多时候，我们能够用字符串API解决，就不需要正则出手，以下是一些例子

```js
var string = "2017-07-01";
var regex = /^(\d{4})-(\d{2})-(\d{2})/;
console.log( string.match(regex) );
// => ["2017-07-01", "2017", "07", "01", index: 0, input: "2017-07-01"]

var result = string.split("-");
console.log( result );
// => ["2017", "07", "01"]
```

在年月日的例子中，我们使用了正则来获取年月日，相比采用分隔符，增加了代码的复杂性。

**2.是否有必要严格匹配**

一般来说，正则由于其复杂性，复杂度上来，需要严格匹配就很困难，应该结合场景，够用就行，或者可以做一些预处理字符串，使得匹配难度降低。

**3.效率**



尽量使用具体字符组代替通配符，减少回溯

    

独立出确定字符，加快匹配判断速度

对多选分支提取公共部分，减少匹配过程中可消除的重复


## 正则表达式操作

### 验证
`检测目标字符串是否有满足匹配的子串`
```js
var regex = /\d/;
var string = "abc123";
console.log( regex.test(string) ); // true
```
### 切分
`在匹配位置进行切分`
```js
var regex = /,/;
var string = "html,css,javascript";
console.log( string.split(regex) );
// => ["html", "css", "javascript"]
```
### 提取
`匹配后提取部分数据`
```js
var regex = /^(\d{4})\D(\d{2})\D(\d{2})$/;
var string = "2017-06-26";
string.search(regex);
console.log( RegExp.$1, RegExp.$2, RegExp.$3 );
// => "2017" "06" "26"
```
### 替换
`替换匹配的信息进行处理`
```js
var string = "2017-06-26";
var today = new Date( string.replace(/-/g, "/") );
console.log( today );
// => Mon Jun 26 2017 00:00:00 GMT+0800 (中国标准时间)
```



