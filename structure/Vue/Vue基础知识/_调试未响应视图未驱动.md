# Vue数据驱动失效

## 前言

**现代前端框架都是为了解决数据与UI同步这个难题发展起来，它们的出现使得与常规DOM节点交互的逻辑被隐藏在框架内部，我们可以使用声明式编程方式使用的数据去驱动UI**，**但是根据不同的框架，其声明式驱动还是有一些限制**，对于Vue来说，初学者和比较熟悉的人，**在出现数据驱动视图失败时，都会一头雾水**，此文结合本人**对Vue原理和自身使用情况，总结了以下数据驱动失效的情况**

## Vue响应式原理

这里简单提一下Vue数据驱动的架构

我们在初始化data时，定义其get、set方法，然后在编译模块时，会调用get方法，此时将此节点相关更新逻辑用一个Watcher包裹，被存入此key对应的Dep，然后在我们对此数据赋值的时候，就会触发Dep的update函数，推动每一个Watcher更新，视图就此更新

![MonfVf.png](https://s2.ax1x.com/2019/11/21/MonfVf.png)


从上图我们可以看到这个数据驱动架构的核心在于对数据定义get、set方法，我们以此展开Vue此实现架构的一些缺陷


## Vue限制

### 对象

#### data嵌套对象上动态添加、删除属性

**添加属性**

由于在实例初始化完毕，**新增的属性，没有被Vue执行 getter/setter 转化**，修改数据无法驱动视图，**删除属性时，无法触发set方法**，也是无法驱动视图的

![Knd9L4.png](https://s2.ax1x.com/2019/10/19/Knd9L4.png)

可以看到我们这里

```js
this.obj.a 
```
操作完成后，我们在控制台打印，并没有发现vue对其进行了getter、setter转化

**解决方案**

问题的核心在于动态添加的属性，没有被Vue执行转化getter/setter,这边Vue提供了两个对外接口**Vue.set Vue.delete**

**函数签名**

```js
// set
Vue.set( target, propertyName/index, value )

参数 对象或者数组  属性名 值

返回值  设置的value

// get
Vue.delete( target, propertyName/index )

参数 对象或数组   属性名

返回值  无
```

**api核心原理**

**为新增属性进行getter、setter转化，同时强制渲染一次视图**


我们尝试使用Vue.set

[![KnwXvT.png](https://s2.ax1x.com/2019/10/19/KnwXvT.png)](https://imgchr.com/i/KnwXvT)

在Vue.set帮助下，我们新增的属性c已经获得了getter、setter转化


**Vue.set注意点**

![KnB8YR.png](https://s2.ax1x.com/2019/10/19/KnB8YR.png)

我们如果要实现动态属性，**注意不要先在对象或者数组中定义该属性**，否则Vue.set会跳过此属性的getter、setter转化和视图渲染，**导致Vue.set失效**

**Vue.delete注意点**

![MoMV8e.png](https://s2.ax1x.com/2019/11/21/MoMV8e.png)

Vue.deleteAPI比较没啥坑点

### 数组

vue2采用的**数组本身也是特殊的对象，当然可以采用对象的处理方式**，但是**尤大考虑到性能问题，采用了代理数组常规方法来达到驱动数组的效果，这里来源是Vue仓库issue,以下是操作数组的缺陷：

```js
// 利用索引直接设置一个数组项
vm.items[indexOfItem] = newValue

// 修改数组的长度
vm.items.length = newLength
```
**解决方案**

**vue选择了使用数组方法来改数组而不是直接修改数组，在数组实例和原型中增加了多一层原型，用于在此拦截数组操作，进行视图驱动**，具体过程，网上很多文章，不再叙述。

#### 增加

```js
// 头部
push
// 尾部
unshift

// 指定位置
splice
```

#### 删除

```js
// 头部
pop
// 尾部
shift

// 指定位置
splice
```

#### 修改

```js
splice

Vue.set
```

这两者其实是一样的，Vue.set内部分支如下

![Kn4cIP.png](https://s2.ax1x.com/2019/10/19/Kn4cIP.png)


## 数据派生属性




### computed

#### 依赖非响应数据

computed其实是属于一个watcher，之所以它拥有响应的能力，其实是对响应式数据进行取值时，被收集到了依赖数据Dep实例中去，每次源数据变化，就会通知watcher更新


![Kn56OJ.png](https://s2.ax1x.com/2019/10/19/Kn56OJ.png)

![Kn7xEj.png](https://s2.ax1x.com/2019/10/19/Kn7xEj.png)

![KnHK8x.png](https://s2.ax1x.com/2019/10/19/KnHK8x.png)

我们在源码的函数defineReactive的上图处，使用console.log打印出数据被赋值时，属性名称和依赖其的watchers,结果发现了我们的计算属性在这个数组中

可以看到我们依赖了message这个响应数据时，我们的computed被收集到了watchers数组中去了,而使用非响应式数组时，此computed未被收集到其他地方的Dep实例中去，此时的computed是正常的，但是由于其没有实例中的响应式数据，没法使用数据驱动它，在某些特殊场景，如果有这样的需求，可以做以下处理

```js
  computed: {
    message2() {
      this.message  // 这里改成一个你需要驱动该computed的数据或者computed即可，只需要取值
      return window.a
    },  
  }
```

这个部分是基于一个真实的需求，用户可以通过按钮或者快捷键来撤销或者重做，达到一次次数总和，**永久**触发一个效果，这里的代码

```js
computed() {
  isShowEffect() {
    return +window.localStorage.getItem("key") > 50
  }
}
```

由于每次操作都需要知道当前操作的次数，所以很自然采用了computed来验证是否达到目标条件，然后发现没效果，其实这里依赖一下记录次数的变量就可以了

```js
computed() {
  isShowEffect() {
    this.actionCount
    return +window.localStorage.getItem("key") > 50
  }
}
```

### 数据被重新进行getter、setter转化

这个情况很容易被遗漏，一般情况下，**如果是对象，我们可以打印出来，看看有没有getter、setter**，就可以判断是不是代码写的有问题，可以使用一些方法处理，**数组的话，仔细阅读官方文档，也是很小成本就知道怎么解决**，就像上面说的，而在一些场景下导致数据被重新转化，目前是极难调试出来的，这个问题也是一个业务场景遇到的

```js
// 正确使用vuex
 computed: {
    count () {
      return store.state.count
    }
  }

// 错误使用vuex
data() {
  return {
    count: store.state.count
  }
}
```


这部分要记住，vuex本身是基于vue包装的，所以数据本身已经拥有了getter、setter转化，不需要再放到组件的data部分，而是应该使用computed去处理













