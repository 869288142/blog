# Vue数据驱动失效

**三大框架的核心是帮助我们更容易让状态和UI进行同步**，对于Vue来说，初学者和比较熟悉的人，在出现数据驱动视图失败时，都会一头雾水，此文结合本人对Vue原理和自身使用情况，总结了以下数据驱动失效的调试方法

## Vue限制

### 对象

**Vue2对象响应缺陷**

#### data嵌套对象上动态添加、删除属性

由于在实例初始化完毕，新增或者删除的属性，没有被Vue执行 getter/setter 转化，所以是无法驱动视图更新的

![image.png](https://s5.ex2x.com/2019/10/19/image.png)

这里我们尝试在data对象的嵌套对象上动态添加新属性，值得注意的是，Vue不推荐在Vue实例和data顶层对属性进行删除和添加的，我觉得一个可能的原因就是会覆盖、或者误删除属性导致应用出问题，通过这个规范可以减少这个问题的发生

![Knd9L4.png](https://s2.ax1x.com/2019/10/19/Knd9L4.png)

可以看到我们这里

```js
this.obj.a 
```
操作完成后，我们在控制台打印，并没有发现vue对其进行了getter、setter转化

**解决方案**

问题的核心在于动态添加的属性，没有被Vue执行转化getter/setter,这边Vue提供了两个对外接口**Vue.set Vue.delete**

**函数签名**

```js
// set
Vue.set( target, propertyName/index, value )

参数 对象或者数组  属性名 值

返回值  设置的value

// get
Vue.delete( target, propertyName/index )

参数 对象或数组   属性名

返回值  无
```

**api核心原理**

**为新增属性进行getter、setter转化，同时强制渲染一次视图**


，我们尝试使用Vue.set

[![KnwXvT.png](https://s2.ax1x.com/2019/10/19/KnwXvT.png)](https://imgchr.com/i/KnwXvT)

在Vue.set帮助下，我们新增的属性c已经获得了getter、setter转化


**Vue.set注意点**

![KnB8YR.png](https://s2.ax1x.com/2019/10/19/KnB8YR.png)

我们如果要实现动态属性，**注意不要先在对象或者数组中定义该属性**，否则Vue.set会跳过此属性的getter、setter转化和视图渲染，**导致Vue.set失效**

### 数组

vue2采用的**响应式方法是可以达到操作数组下标来驱动数组的**，但是**尤大考虑到性能问题，采用了代理数组常规方法来达到驱动数组的效果，这边是看了尤大的issue,一下子找不到了**

```js
// 利用索引直接设置一个数组项
vm.items[indexOfItem] = newValue

// 修改数组的长度
vm.items.length = newLength
```
**解决方案**

vue在数组实例和原型中增加了多一层原型，用于在此拦截数组操作，进行视图驱动

#### 增加

```js
// 头部
push
// 尾部
unshift

// 指定位置
splice
```

#### 删除

```js
// 头部
pop
// 尾部
shift

// 指定位置
splice
```

#### 修改

```js
splice

Vue.set
```

这两者其实是一样的，Vue.set内部分支如下

![Kn4cIP.png](https://s2.ax1x.com/2019/10/19/Kn4cIP.png)


### computed

#### 依赖非响应数据

computed其实是属于一个watcher，之所以它拥有响应的能力，其实是对响应式数据进行取值时，被收集到了依赖数据Dep实例中去，每次源数据变化，就会通知watcher更新


![Kn56OJ.png](https://s2.ax1x.com/2019/10/19/Kn56OJ.png)

![Kn7xEj.png](https://s2.ax1x.com/2019/10/19/Kn7xEj.png)

![KnHK8x.png](https://s2.ax1x.com/2019/10/19/KnHK8x.png)

我们在源码的函数defineReactive的上图处，使用console.log打印出数据被赋值时，属性名称和依赖其的watchers,结果发现了我们的计算属性在这个数组中

可以看到我们依赖了message这个响应数据时，我们的computed被收集到了watchers数组中去了,而使用非响应式数组时，此computed未被收集到其他地方的Dep实例中去，此时的computed是正常的，但是由于其没有实例中的响应式数据，没法使用数据驱动它，在某些特殊场景，如果有这样的需求，可以做以下处理

```js
  computed: {
    message2() {
      this.message  // 这里改成一个你需要驱动该computed的数据或者computed即可，只需要取值
      return window.a
    },  
  }
```

这个部分是基于一个真实的需求，用户可以通过按钮或者快捷键来撤销或者重做，达到一次次数总和，**永久**触发一个效果，这里的代码

```js
computed() {
  isShowEffect() {
    return +window.localStorage.getItem("key") > 50
  }
}
```

由于每次操作都需要知道当前操作的次数，所以很自然采用了computed来验证是否达到目标条件，然后发现没效果，其实这里依赖一下记录次数的变量就可以了

```js
computed() {
  isShowEffect() {
    this.actionCount
    return +window.localStorage.getItem("key") > 50
  }
}
```

### 数据被重新进行getter、setter转化

这个情况很容易被遗漏，一般情况下，**如果是对象，我们可以打印出来，看看有没有getter、setter**，就可以判断是不是代码写的有问题，可以使用一些方法处理，**数组的话，仔细阅读官方文档，也是很小成本就知道怎么解决**，就像上面说的，而在一些场景下导致数据被重新转化，目前是极难调试出来的，这个问题也是一个业务场景遇到的

```js
// 正确使用vuex
 computed: {
    count () {
      return store.state.count
    }
  }

// 错误使用vuex
data() {
  return {
    count: store.state.count
  }
}
```


这部分要记住，vuex本身是基于vue包装的，所以数据本身已经拥有了getter、setter转化，不需要再放到组件的data部分，而是应该使用computed去处理













