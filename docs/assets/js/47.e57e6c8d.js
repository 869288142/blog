(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{226:function(t,s,n){"use strict";n.r(s);var a=n(0),e=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"promise"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#promise","aria-hidden":"true"}},[t._v("#")]),t._v(" promise")]),t._v(" "),n("p",[t._v("异步：")]),t._v(" "),n("p",[t._v("核心：")]),t._v(" "),n("pre",[n("code",[t._v("现在运行的部分和将来运行的部分之间的关系\n")])]),t._v(" "),n("p",[t._v("常用方案：")]),t._v(" "),n("pre",[n("code",[t._v("从现在到将来的等待，通常使用一个回调函数在结果返回时得到结果\n")])]),t._v(" "),n("p",[t._v("控制台(因为console族是由宿主环境即游览器实现的)可能会使用异步机制，在出现问题时使用断点调试或者JSON化形成快照")]),t._v(" "),n("p",[t._v("异步和并行的区别：")]),t._v(" "),n("pre",[n("code",[t._v("异步：现在与将来的时间间隙\n并行：同时发生的事\n")])]),t._v(" "),n("p",[t._v("js引擎是单线程的，但是函数级别上执行顺序仍然存在不可预测")]),t._v(" "),n("p",[t._v("并发交互 并发协作")]),t._v(" "),n("p",[t._v("回调存在的问题：")]),t._v(" "),n("pre",[n("code",[t._v("回调地狱：人脑计划和回调驱动异步不匹配，导致思维难以迅速找到整个回调流程\n\n信任问题： \n        1.调用过早\n        2.调用过晚或者没有调用\n        3.调用次数不正确（过多或者过少）\n        4.没有把参数正确传回\n        5.吞掉错误或者异常\n")])]),t._v(" "),n("p",[t._v("事件循环(eventloop)")]),t._v(" "),n("pre",[n("code",[t._v("每一次时间循环称为一个tick\n")])]),t._v(" "),n("p",[t._v("任务队列")]),t._v(" "),n("pre",[n("code",[t._v("在tick后面挂载的队列\n")])]),t._v(" "),n("p",[t._v("回调带来的问题导致的需求：")]),t._v(" "),n("pre",[n("code",[t._v("一种更同步、更顺序、更阻塞的方式表达异步来提供与我们大脑思维一致\n")])]),t._v(" "),n("p",[t._v("Promise顺势诞生：")]),t._v(" "),n("pre",[n("code",[t._v("对于回调函数带来的问题的解决：\n\n1.调用过早\n\n    本质：一个方法可能会同步执行也可能会异步执行，导致结果不可靠\n")])]),t._v(" "),n("div",{staticClass:"language-javascript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[t._v("    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("result")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("data")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" a "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//0(同步回调调用)、1(异步回调调用)")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("ajax")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"..pre-cached-url.."')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" result "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    a"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("pre",[n("code",[t._v("    解决方案：then方法总是会异步调用其回调\n\n2.调用过晚\n\n    解决方案:在Promise对象执行resolve或reject方法后，then注册的回调函数会被自动执行\n\n3.没有被调用\n\n    解决方案：\n    1.只要决议，那么回调函数就会调用完成回调和拒绝回调其中一个\n    2.回调函数出现错误，可以在后续代码中捕获这些错误，当然回调已经被执行了\n    3.Promise本身永远不被决议，可以使用race这个竞态机制来获取一个输出信号，防止其永久挂住程序\n\n4.调用次数过多或者过少\n\n    解决方案：Promise只会接受第一次决议，并默默地忽略任何后续调用\n\n5.没有把参数正确传回\n\n    解决方案：Promise在决议时，只接受第一个参数，如果需要多个参数，可以使用数组或者对象包裹参数\n\n6.吞掉错误或者异常          \n\n    解决方案：在Promise创建过程中或者查看决议过程中，出现js异常，那么异常会被捕捉并且使得这个promise被拒绝              \n\n7.保证Promise可信任(保证返回的值为Promise)\n\n    解决方案：Promise.resolve()\n    1.传入一个非Promise、非thenable值，那么会得到用这个值填充promise\n    2.传入一个真正的promise，那么会原样返回这个promise\n    3.传入一个非Promise的thenable值，会展开这个值，持续到得到一个非类Promise的值    \n")])]),t._v(" "),n("p",[t._v("第三方提供任务结束的能力，由我们决定代码下一步的行动")]),t._v(" "),n("p",[t._v("Promise 基本API")]),t._v(" "),n("div",{staticClass:"language-javascript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Promise")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("resolve"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("reject")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("、reject")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("catch")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),n("p",[t._v("如何验证是否为promise 检测是否具有then方法")]),t._v(" "),n("p",[t._v("快捷创建已经被决议的Promise：")]),t._v(" "),n("div",{staticClass:"language-javascript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[t._v("    Promise"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//完成")]),t._v("\n    Promise"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("reject")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//拒绝")]),t._v("\n")])])]),n("p",[t._v("then和catch方法也会返回一个新的Promise")]),t._v(" "),n("p",[n("strong",[t._v("不要依赖promise回调的顺序")])]),t._v(" "),n("p",[t._v("局限性：\n1.顺序错误处理，导致Promise链中的错误容易被忽略掉\n2.单一值导致后续处理变量繁琐\n3.单决议在事件中需要注意创建新的Promise链\n4.Promise导致的性能问题")])])}],!1,null,null,null);s.default=e.exports}}]);