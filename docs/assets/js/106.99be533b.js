(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{174:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"vue组件通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue组件通信","aria-hidden":"true"}},[t._v("#")]),t._v(" Vue组件通信")]),t._v(" "),e("h2",{attrs:{id:"通信类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通信类型","aria-hidden":"true"}},[t._v("#")]),t._v(" 通信类型")]),t._v(" "),e("p",[t._v("父子组件")]),t._v(" "),e("p",[t._v("同级组件")]),t._v(" "),e("p",[t._v("跨级组件")]),t._v(" "),e("h2",{attrs:{id:"通信方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通信方式","aria-hidden":"true"}},[t._v("#")]),t._v(" 通信方式")]),t._v(" "),e("h3",{attrs:{id:"prop结合emit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#prop结合emit","aria-hidden":"true"}},[t._v("#")]),t._v(" prop结合emit")]),t._v(" "),e("p",[e("strong",[t._v("缺点：")]),t._v("\n需要书写大量自定义事件在组件标签上")]),t._v(" "),e("h3",{attrs:{id:"dispatch-broadcast"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-broadcast","aria-hidden":"true"}},[t._v("#")]),t._v(" dispatch broadcast")]),t._v(" "),e("p",[t._v("dispatch和broadcast，dispatch用于向上级派发事件，broadcast用于向下派发事件\n，在Vue实例中可以在events定义事件处理函数来接受")]),t._v(" "),e("p",[e("strong",[t._v("缺点：")]),t._v("\n基于组件树结构事件流让人难以理解，会在组件结构扩展中，变得越来越脆弱，并且无法解决兄弟组件通信问题")]),t._v(" "),e("h3",{attrs:{id:"parent-children"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parent-children","aria-hidden":"true"}},[t._v("#")]),t._v(" $parent $children")]),t._v(" "),e("p",[t._v("可以通过this.$parent直接访问父实例或者组件，也可以通过this.$children访问子实例或者组件，这两个属性可以无限递归，直到根实例或者最内层组件")]),t._v(" "),e("p",[e("strong",[t._v("缺点：")]),t._v("\n使得父子组件过于耦合，并且不应该直接修改父组件的数据，这样会导致，只看父组件，很难理解它的状态，因为任何组件都可能更改它的状态。")]),t._v(" "),e("h3",{attrs:{id:"bus总线"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bus总线","aria-hidden":"true"}},[t._v("#")]),t._v(" bus总线")]),t._v(" "),e("p",[t._v("通过创建一个名为bus的空Vue实例，组件通过bus.$emit('eventName',value)来向bus实例派发方法，接受实例在自身mounted时，在bus实例上使用bus.$on('eventName',arrowFuntion)注册事件监听来处理数据")]),t._v(" "),e("p",[e("strong",[t._v("缺点：")]),t._v("\n使得事件监听函数分布在各个Vue实例中，")]),t._v(" "),e("h3",{attrs:{id:"vuex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex","aria-hidden":"true"}},[t._v("#")]),t._v(" Vuex")]),t._v(" "),e("p",[t._v("为组件的状态提供了统一管理的方案，所有的状态和行为被保存在一个中央仓库")]),t._v(" "),e("p",[e("strong",[t._v("优点：")])]),t._v(" "),e("ol",[e("li",[t._v("只需向vuex派发一个事件名，在vuex实例中完成业务逻辑，无需书写自定义事件")]),t._v(" "),e("li",[t._v("业务逻辑都在mutations或者actions，集中，而且在有必要时使用module划分仓库")]),t._v(" "),e("li",[t._v("由于vuex数据是响应式的，使用vuex数据对应的视图会在数据变更时自动更新")]),t._v(" "),e("li",[t._v("可以对一些数据的getter提供一个全局的方法，避免这组件内部这部分的重复编码")])])])}],!1,null,null,null);a.default=s.exports}}]);