(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{214:function(n,o,t){"use strict";t.r(o);var a=t(0),s=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,o=n.$createElement,t=n._self._c||o;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this","aria-hidden":"true"}},[n._v("#")]),n._v(" this")]),n._v(" "),t("p",[n._v("调用时绑定 类似动态作用域")]),n._v(" "),t("p",[n._v("this在很多语言都有，表示当前对象，不像其它语言中，this在js中有很多怪异的现象：")]),n._v(" "),t("p",[n._v("1.一个常见且有趣的场景，js一些对象的实例方法可以被其它对象使用，有一个很有趣的比喻，我们家没有锅，去借别人家的，但是出来的效果是一致的")]),n._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[n._v("\n")])])]),t("p",[n._v("箭头函数this是静态绑定的，指向其最近的作用域链中的this")]),n._v(" "),t("p",[n._v("这里this按照作用域链来查找\n作用域类型 全局作用域 函数作用域")]),n._v(" "),t("p",[n._v("默认绑定\nfunction foo() {\nconsole.log( this.a );\n}\nvar a = 2;\nfoo(); // 2")]),n._v(" "),t("p",[n._v("隐式绑定  只有最后一层会影响调用位置\nfunction foo() {\nconsole.log( this.a );\n}\nvar obj2 = {\na: 42,\nfoo: foo\n};\nvar obj1 = {\na: 2,\nobj2: obj2\n};\nobj1.obj2.foo(); // 42")]),n._v(" "),t("p",[n._v("显式绑定\ncall apply")]),n._v(" "),t("p",[n._v("硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值：\nfunction foo(something) {\nconsole.log( this.a, something );\nreturn this.a + something;\n}\nvar obj = {\na:2\n};\nvar bar = function() {\nreturn foo.apply( obj, arguments );\n};\nvar b = bar( 3 ); // 2 3")]),n._v(" "),t("p",[n._v("另一种使用方法是创建一个i 可以重复使用的辅助函数：\nfunction foo(something) {\nconsole.log( this.a, something );\nreturn this.a + something;\n}\n// 简单的辅助绑定函数\nfunction bind(fn, obj) {\nreturn function() {\nreturn fn.apply( obj, arguments );\n};\n}\nvar obj = {\na:2\n};\nvar bar = bind( foo, obj );\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5")]),n._v(" "),t("p",[n._v("new绑定")]),n._v(" "),t("p",[n._v("优先级")]),n._v(" "),t("p",[n._v("判断this\n现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的\n顺序来进行判断：")]),n._v(" "),t("ol",[t("li",[n._v("函数是否在new 中调用（new 绑定）？如果是的话this 绑定的是新创建的对象。\nvar bar = new foo()")]),n._v(" "),t("li",[n._v("函数是否通过call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是\n指定的对象。\nvar bar = foo.call(obj2)")]),n._v(" "),t("li",[n._v("函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上\n下文对象。\nvar bar = obj1.foo()")]),n._v(" "),t("li",[n._v("如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到\n全局对象。\nvar bar = foo()")])])])}],!1,null,null,null);o.default=s.exports}}]);