(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{251:function(n,e,t){"use strict";t.r(e);var c=t(0),s=Object(c.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"选择器整理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选择器整理","aria-hidden":"true"}},[n._v("#")]),n._v(" 选择器整理")]),n._v(" "),t("p",[n._v("读完《CSS权威指南》，对选择器有如下整理：")]),n._v(" "),t("p",[n._v("selector 本质上是执行元素样式匹配规则，我们可以利用它来限定某些元素\n选择器类型：")]),n._v(" "),t("pre",[t("code",[n._v("\x3c!-- 实体，即HTML中存在 --\x3e\n\n1.通配选择器 * 匹配任意\n2.元素选择器 p \n3.类选择器 .class\n4.ID选择器 #id\n5.属性选择器 element[rep] (不常用) \n\n\x3c!-- 虚体，即HTML本身不存在 --\x3e\n\n1.伪类(一些在某种行为会被自动定义的类,有点类似游览器会自动帮我管理这些内置类)\n\n  \x3c!-- 表现 --\x3e\n  1.link\n  2.visited\n  3.focus\n  4.hover\n  5.active\n  \x3c!-- 结构 --\x3e\n  1.first-child\n  2.last-child\n  3.nth-chlid(an+b)\n  4.not()\n  \x3c!-- 内容 --\x3e\n  1.empty\n\n2.伪元素(向文档中插入的假想元素)\n\n  \x3c!-- 表现 --\x3e\n  before\n  after\n")])]),n._v(" "),t("p",[n._v("选择器规则：")]),n._v(" "),t("pre",[t("code",[n._v("\x3c!-- 选择器组合 --\x3e\n1.分组 逗号分隔(相同属性聚集)\n2.交集 \n\n\x3c!-- 文档结构 --\x3e\n1.后代选择器 空格\n2.子代选择器 >\n3.兄弟选择器 +  \n")])])])}],!1,null,null,null);e.default=s.exports}}]);