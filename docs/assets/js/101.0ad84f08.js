(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{170:function(e,n,t){"use strict";t.r(n);var v=t(0),s=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"vue组件通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue组件通信","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue组件通信")]),e._v(" "),t("p",[e._v("1.父子组件")]),e._v(" "),t("pre",[t("code",[e._v("   1.子组件修改父组件状态\n     1.1自定义事件\n        子组件提交emit触发自定义事件\n        父组件定义自定义事件绑定事件处理事件\n    缺点：需要书写大量自定义事件在组件标签上\n    应用场景：开发通用性较高的自定义组件\n")])]),e._v(" "),t("p",[e._v("2.同级组件")]),e._v(" "),t("p",[e._v("3.跨级组件")]),e._v(" "),t("pre",[t("code",[e._v("    1.1dispatch和broadcast，dispatch用于向上级派发事件，broadcast用于向下派发事件\n    ，在Vue实例中可以在events定义事件处理函数来接受\n    缺点：基于组件树结构事件流让人难以理解，会在组件结构扩展中，变得越来越脆弱，并且无法解决兄弟组件通信问题\n")])]),e._v(" "),t("p",[e._v("父链；")]),e._v(" "),t("pre",[t("code",[e._v("    可以通过this.$parent直接访问父实例或者组件，也可以通过this.$children访问子实例或者组件，这两个属性可以无限递归，直到根实例或者最内层组件\n    缺点：使得父子组件过于耦合，并且不应该直接修改父组件的数据，这样会导致，只看父组件，很难理解它的状态，因为任何组件都可能更改它的状态。\n")])]),e._v(" "),t("p",[e._v("bus总线")]),e._v(" "),t("pre",[t("code",[e._v("    通过创建一个名为bus的空Vue实例，组件通过bus.$emit('eventName',value)来向bus实例派发方法，接受实例在自身mounted时，在bus实例上使用bus.$on('eventName',arrowFuntion)注册事件监听来处理数据\n    缺点：使得事件监听函数分布在各个Vue实例中，\n")])]),e._v(" "),t("p",[e._v("Vuex")]),e._v(" "),t("pre",[t("code",[e._v("    为组件的状态提供了统一管理的方案，所有的状态和行为被保存在一个中央仓库\n    优点：\n    1.只需向vuex派发一个事件名，在vuex实例中完成业务逻辑，无需书写自定义事件\n    2.业务逻辑都在mutations或者actions，集中，而且在有必要时使用module划分仓库\n    3.由于vuex数据是响应式的，使用vuex数据对应的视图会在数据变更时自动更新\n    4.可以对一些数据的getter提供一个全局的方法，避免这组件内部这部分的重复编码\n")])])])}],!1,null,null,null);n.default=s.exports}}]);